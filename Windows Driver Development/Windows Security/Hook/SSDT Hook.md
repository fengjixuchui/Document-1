对应用程序而言，操作系统内核的作用体现在提供一组可以供其调用的函数，算是系统内核为应用软件提供的服务，所以称为`系统服务(system service)`或`系统调用(system call)`


内核被动和主动：
- 被动：从应用程序看，进程是主动和活跃的，内核是被动的，只是应进程的要求而提供服务。
- 从整个系统看的话，内核是有活性的一面，诸多应用进程就是在内核的调度下运行的。(`进程调度`)


`系统服务`是在系统空间实现，软件是在用户空间实现。二者之间有着空间的间隔，实质上是CPU运行模式的不同。所以，在应用软件与内核之间必定存在着一个明确定义的`系统调用界面`


一般而言只有三种手段或原因可以使运行于用户空间的CPU转入系统空间：
- 中断(Interrupt):在开启了中断机制的情况下，只要有外部设备的中断请求到来，CPU就会自动转入系统空间。**中断只发生在两条指令之间，因而不会使正在执行的指令半途而废。对于CPU而言，因中断而进入系统空间是被动的，并且在CPU完全无法预知何时发生，所以中断的发生是异步的。
- 异常(Exception):不管是在用户空间或系统空间，执行指令失败都会引起一次`异常`，CPU也会因此转入系统空间。同样，对于CPU而言，因异常而进入系统空间也是被动的、无法预知的。但是，这只是一般而言，实践中也可以通过故意引起异常而进入内核。
- 自陷(Trap):为了让CPU能够主动的进入系统空间，绝大多数CPU都设有专门的`自陷`指令，系统调用通常就是靠自陷指令实现的。一执行这样的指令，CPU就转入了系统空间并从某个预定的地址开始执行指令，就像掉进了陷阱一样。**自陷指令在形式上与中断相似，就像是一次由CPU主动发出的中断请求。**这看起来更像是一次子程序调用。

Inter x86系列CPU还有一种称为`调用门`的机制，这此机制可以认为只是对自陷机制的改进，增加了一对指令`sysenter`和`sysexit`，用来实现一种称为`快速系统调用`的机制，并为此而增加了三个寄存器。

传统调用是通过自陷指令`int 0x2e`进入内核的，后来使用`快速系统调用`

用户空间到系统空间的转换过程：
![exg](./images/1567581572(1).jpg)

```
ReadFile ====> 中介函数NtReadFile ==========> NtReadFile
```

使用快速系统调用之后的代码：
![pic1](./images/1567582661(1).jpg)

代码中的`KUSER_SHARED_SYSCALL`是用户空间的一个地址，实际上是`0x7FFE0300`,这里存储着一个函数指针，指向`KiIntSystemCall`或`KiFastSystemCall`两个函数之一。系统在初始化的时候判断是否支持快速系统调用。
![pic2](./images/1567582867(1).jpg)
![pic3](./images/1567582931(1).jpg)


这两个函数都在`ntdll.dll`中，这个dll在系统的初始化阶段就会被装入，内核判断处理器是否支持快速系统调用，从而在dll中找到函数的地址，将其写入用户空间地址`0x7FFE0300`,其实CPU写入的是系统空间的地址`0xFFDF0300`，但是系统空间`0xffdf0000`的地方与用户空间`0x7ffe0000`的地方就好像是一条隧道的两端，两块64KB的虚拟内存区间都映射到同一块物理内存。



## 系统调用的内核入口 KiSystemService

当CPU执行`int 0x2e`时，CPU就进入了内核中的这个函数。

当用户空间通过自陷指令进入内核时，CPU自动将下列信息压入系统空间堆栈：
1. 用户空间的堆栈位置，包括堆栈段寄存器SS和堆栈指针ESP的内容
2. CPU中“标志寄存器”EFLAGS的内容
3. 用户空间的指令位置，包括代码段寄存器CS和指令指针EIP的内容。

进入系统空间时，系统空间堆栈上的内容如下：
![pic3](./images/1567585530(1).jpg)


那么系统空间堆栈又在哪里呢？每个线程都有自己的系统空间堆栈，其堆栈段寄存器SS和堆栈指针ESP的内容保存在一个`任务状态段`即`TSS`的数据结构里面。与此相应，CPU中有个称为`任务寄存器`即`TR`的段寄存器。每当从用户空间进入系统空间时，CPU就自动根据TR的指引从TSS中获取当前进程的SS和ESP两个寄存器的值。


线程控制块`KTHREAD`结构中有个指针`ServiceTable`，指向本线程的系统调用表。这意味着不同的线程可以有不同的系统调用表。不过，实际使用中每个线程的ServiceTable不是指向`KeServiceDescriptorTable`就是指向`KeServiceDescriptorTableShadow`，前者仅用于基本系统调用，后者既可用于基本系统调用也可用于win32扩充系统调用。
