# 程序实体的那些事

## Go 语言的类型推断可以带来哪些好处？

Go 语言的类型推断可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会给代码的维护带来额外负担（实际上，它恰恰可以避免散弹式的代码修改），更不会损失程序的运行效率。

类型推断提升了程序的灵活性，但是也意味着可读性会降低，有利有弊，需要权衡





## 变量的<font color='red'>重声明</font>是什么意思？

这涉及了短变量声明。通过使用它，我们可以对同一个代码块中的变量进行重声明。

> 既然说到了代码块，我先来解释一下它。在 Go 语言中，代码块一般就是一个由花括号括起来的区域，里面可以包含表达式和语句。Go 语言本身以及我们编写的代码共同形成了一个非常大的代码块，也叫全域代码块。这主要体现在，只要是公开的全局变量，都可以被任何代码所使用。相对小一些的代码块是代码包，一个代码包可以包含许多子代码包，所以这样的代码块也可以很大。
>
> 接下来，每个源码文件也都是一个代码块，每个函数也是一个代码块，每个if语句、for语句、switch语句和select语句都是一个代码块。甚至，switch或select语句中的case子句也都是独立的代码块。走个极端，我就在main函数中写一对紧挨着的花括号算不算一个代码块？当然也算，这甚至还有个名词，叫“空代码块”。

回到变量重声明的问题上。其含义是对已经声明过的变量再次声明。变量重声明的前提条件如下。

1. 由于变量的类型在其初始化时就已经确定了，所以对它再次声明时赋予的类型<font color='red'>**必须与其原本的类型相同**</font>，否则会产生编译错误。
2. 变量的重声明只<font color='red'>**可能发生在某一个代码块中**</font>。如果与当前的变量重名的是外层代码块中的变量，那么就是另外一种含义了
3. 变量的重声明<font color='red'>**只有在使用短变量声明时才会发生**</font>，否则也无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字var的声明语句，但是这时就不能与同一个代码块中的任何变量有重名了。
4. 被“声明并赋值”的变量<font color='red'>**必须是多个，并且其中至少有一个是新的变量**</font>。这时我们才可以说对其中的旧变量进行了重声明。

这样来看，变量重声明其实算是一个语法糖（或者叫便利措施）。它允许我们在使用短变量声明时不用理会被赋值的多个变量中是否包含旧变量。可以想象，如果不这样会多写不少代码。



例：

```go
var err error
n, err := io.WriteString(os.Stdout, "Hello, everyone!\n")
```

使用短变量声明对新变量n和旧变量err进行了“声明并赋值”，这时也是对后者的重声明。



## 如果一个变量与其外层代码块中的变量重名会出现什么状况？

例：

```go
package main

import "fmt"

var block = "package"

func main() {
  block := "function"
  {
    block := "inner"
    fmt.Printf("The block is %s.\n", block)
  }
  fmt.Printf("The block is %s.\n", block)
}
```

这个命令源码文件中有四个代码块，它们是：全域代码块、main包代表的代码块、main函数代表的代码块，以及在main函数中的一个用花括号包起来的代码块。



我在后三个代码块中分别声明了一个名为block的变量，并分别把字符串值"package"、"function"和"inner"赋给了它们。此外，我在后两个代码块的最后分别尝试用fmt.Printf函数打印出“The block is %s.”。这里的“%s”只是为了占位，程序会用block变量的实际值替换掉。

### 回答

运行后打印出的内容是：

```shell
The block is inner.
The block is function.
```

### 解析

**<font color='red'>声明重名的变量是无法通过编译的，用短变量声明对已有变量进行重声明除外，但这只是对于同一个代码块而言的。</font>**

对于不同的代码块来说，其中的变量重名没什么大不了，照样可以通过编译。即使这些代码块有直接的嵌套关系也是如此.



我引用变量时到底用的是哪一个？

这其实有一个很有画面感的查找过程。这个查找过程不只针对于变量，还适用于任何程序实体。如下面所示。

- 首先，代码引用变量的时候总会<font color='red'>最优先查找当前代码块</font>中的那个变量。注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并<font color='red'>不包含任何子代码块</font>。
- 其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块开始，<font color='red'>一层一层地向外查找</font>。
- 一般情况下，程序会一直查到当前代码包代表的代码块。如果<font color='red'>仍然找不到，那么 Go 语言的编译器就会报错了</font>。



> 还记得吗？如果我们<font color='cornflowerblue'>在当前源码文件中导入了其他代码包，那么引用其中的程序实体时，是需要以限定符为前缀的。所以程序在找代表变量未加限定符的名字（即标识符）的时候，是不会去被导入的代码包中查找的</font>。
>
> 但有个特殊情况，如果我们把代码包导入语句写成<font color='cornflowerblue'>import . "XXX"</font>的形式（注意中间的那个“.”），那么就会让<font color='cornflowerblue'>这个“XXX”包中公开的程序实体，被当前源码文件中的代码，视为当前代码包中的程序实体。</font> 比如，如果<font color='cornflowerblue'>有代码包导入语句import . fmt，那么我们在当前源码文件中引用fmt.Printf函数的时候直接用Printf就可以了</font>。在这个特殊情况下，程序在查找当前源码文件后会先去查用这种方式导入的那些代码包。



从作用域的角度也可以说，虽然通过`var block = "package"`声明的变量作用域是整个main代码包，但是在main函数中，它却被那两个同名的变量**“屏蔽”**了。



## 不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？

为了方便描述，我就把**不同代码块中的重名变量叫做“可重名变量”**吧。注意，<font color='red'>在同一个代码块中不允许出现重名的变量，这违背了 Go 语言的语法</font>。

1. 变量重声明中的变量一定是在某一个代码块内的。注意，这里的“某一个代码块内”并不包含它的任何子代码块，否则就变成了“多个代码块之间”。而可重名变量指的正是在多个代码块之间由相同的标识符代表的变量。
2. 变量重声明是对同一个变量的多次声明，这里的变量只有一个。而可重名变量中涉及的变量肯定是有多个的。
3. 不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型。而可重名变量之间不存在类似的限制，它们的类型可以是任意的。
4. 如果可重名变量所在的代码块之间，存在直接或间接的嵌套关系，那么它们之间一定会存在“屏蔽”的现象。但是这种现象绝对不会在变量重声明的场景下出现。

![img](https://raw.githubusercontent.com/supermanc88/ImageSources/master/5e68210d5639f9e42738f21bd9eb1e89.png)

## 怎样判断一个变量的类型？

```go
package main

import "fmt"

var container = []string{"zero", "one", "two"}

func main() {
  container := map[int]string{0: "zero", 1: "one", 2: "two"}
  fmt.Printf("The element is %q.\n", container[1])
}
```

那么，怎样在打印其中元素之前，正确判断变量container的类型？



### 回答

答案是使用“类型断言”表达式。具体怎么写呢？

```go
value, ok := interface{}(container).([]string)
```

这里有一条赋值语句。在赋值符号的右边，是一个类型断言表达式。

它包括了用来把container变量的值转换为空接口值的interface{}(container)。

以及一个用于判断前者的类型是否为切片类型 []string 的 .([]string)。

这个表达式的结果可以被赋给两个变量，在这里由value和ok代表。变量ok是布尔（bool）类型的，它将代表类型判断的结果，true或false。

如果是true，那么被判断的值将会被自动转换为[]string类型的值，并赋给变量value，否则value将被赋予nil（即“空”）。

顺便提一下，这里的ok也可以没有。也就是说，类型断言表达式的结果，可以只被赋给一个变量，在这里是value。

但是这样的话，当判断为否时就会引发异常。

### 解析

正式说明一下，类型断言表达式的语法形式是<font color='red'>x.(T)</font>。其中的x代表要被判断类型的值。这个<font color='red'>值当下的类型必须是接口类型</font>的，不过具体是哪个接口类型其实是无所谓的。

所以，当这里的container变量类型不是任何的接口类型时，我们就需要先把它转成某个接口类型的值。

如果container是某个接口类型的，那么这个类型断言表达式就可以是container.([]string)。这样看是不是清晰一些了？

在 Go 语言中，<font color='red'>interface{}代表空接口，任何类型都是它的实现类型。</font>